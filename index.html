<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dashboard LoRa ‚Äì Protegido</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Leaflet (mapa) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    /* ----- SPLASH SCREEN ----- */
    #splash {
      position: fixed; inset: 0;
      background: url('https://i.ibb.co/fgXzxxM/VID-007-3.jpg') no-repeat center center fixed;
      background-size: cover;
      display: flex; justify-content: center; align-items: center;
      z-index: 99999;
    }
    #splash .splash-content {
      text-align: center; color: white; background: rgba(0,0,0,.6);
      padding: 40px; border-radius: 15px; box-shadow: 0 4px 8px rgba(0,0,0,.3);
      animation: fadeIn 2s ease-in-out;
    }
    #splash h1 { font-size: 3.5em; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,.5); }
    #splash p { font-size: 1.6em; margin-bottom: 30px; }
    #splash button {
      padding: 12px 30px; font-size: 1.3em; background: #28a745; color: #fff;
      border: none; border-radius: 8px; cursor: pointer; transition: background-color .3s ease;
    }
    #splash button:hover { background: #218838; }
    @keyframes fadeIn { 0%{opacity:0;transform:scale(.9)} 100%{opacity:1;transform:scale(1)} }

    /* ----- ESTILOS DEL DASHBOARD ----- */
    :root {
      --fondo-claro: #f4f4f4; --texto-claro: #333;
      --fondo-oscuro: #1e1e1e; --texto-oscuro: #eee;
      --card-claro: #fff; --card-oscuro: #2c2c2c;
    }
    body {
      font-family: Arial, sans-serif; margin: 0; padding: 0;
      background-color: var(--fondo-claro); color: var(--texto-claro);
      transition: background .3s, color .3s;
    }
    body.dark-mode { background-color: var(--fondo-oscuro); color: var(--texto-oscuro); }

    header {
      background: #222; color: #fff; padding: 1rem; text-align: center; position: relative;
    }
    #toggleTheme {
      position: absolute; top: 10px; right: 10px; background: #444; color: white; border: none;
      padding: 5px 10px; border-radius: 5px; cursor: pointer;
    }

    .config { padding: 1rem; background: #fff0e0; text-align: center; }
    body.dark-mode .config { background: #3b2f2f; }

    .umbral-row { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 1rem; margin-top: 1rem; }
    .umbral-row label { display: flex; align-items: center; gap: .3rem; font-weight: 500; }
    .umbral-row input { width: 70px; padding: 5px; text-align: right; }

    .cards { display: flex; flex-wrap: wrap; justify-content: center; gap: 1rem; padding: 1rem; }
    .card {
      background: var(--card-claro); padding: 1rem; border-radius: 10px; min-width: 180px; text-align: center;
      box-shadow: 0 0 10px rgba(0,0,0,.1); transition: background .3s, color .3s;
    }
    body.dark-mode .card { background: var(--card-oscuro); box-shadow: 0 0 10px rgba(255,255,255,.05); }

    .critical { background-color: #ffdddd; border: 2px solid red; }
    body.dark-mode .critical { background-color: #733; }

    canvas { max-width: 100%; }

    #lastUpdate, #lastWhatsApp, #loginStatus { text-align: center; margin: 1rem; font-weight: bold; }

    #refreshBtn, #testBtn, #logoutBtn, #wakeBtn {
      display: inline-block; margin: .5rem .5rem; padding: .5rem 1rem; font-size: 1rem; color: white;
      border: none; border-radius: 5px; cursor: pointer;
    }
    #testBtn { background: #4CAF50; } #testBtn:hover { background: #3e8e41; }
    #logoutBtn { background: #c0392b; } #logoutBtn:hover { background: #992d22; }
    #wakeBtn { background: #7f8c8d; } #wakeBtn:hover { background: #667273; }

    .notif {
      position: fixed; bottom: 20px; right: 20px; background: #4caf50; color: white;
      padding: 10px 20px; border-radius: 8px; font-weight: bold; z-index: 9999;
      box-shadow: 0 2px 8px rgba(0,0,0,.3); opacity: 0; transform: translateY(20px); transition: all .4s;
    }
    .notif.show { opacity: 1; transform: translateY(0); }

    /* ----- MAPA ----- */
    .map-card {
      background: var(--card-claro); margin: 16px; padding: 12px; border-radius: 12px;
      box-shadow: 0 0 10px rgba(0,0,0,.1);
    }
    body.dark-mode .map-card { background: var(--card-oscuro); box-shadow: 0 0 10px rgba(255,255,255,.05); }
    #map { width: 100%; height: 320px; border-radius: 10px; }
    #mapStatus { text-align: center; margin-top: 8px; font-weight: 600; }

    /* L√≠nea de estado/controles extra */
    .toolbar {
      display:flex; flex-wrap:wrap; gap:.75rem; justify-content:center; align-items:center; margin:.5rem auto 0;
    }
    .toolbar label { display:flex; align-items:center; gap:.4rem; background:#fff; border-radius:8px; padding:.35rem .6rem; }
    body.dark-mode .toolbar label { background:#2c2c2c; }
  
@keyframes blinkBorder {
  0%   { box-shadow: 0 0 10px 2px red; }
  50%  { box-shadow: 0 0 0 0 red; }
  100% { box-shadow: 0 0 10px 2px red; }
}
.card.alerta, .card.critical { border: 2px solid red !important; animation: blinkBorder 1s infinite; }
</style>

  <!-- üîå Pump Control Styles (scoped) -->
  <style>
    #pumpWrap { max-width:760px; margin:16px auto; padding:0 16px; }
    #pumpWrap h1{ font-size:22px; margin:8px 0 10px; color:#00e5ff; text-shadow:0 0 6px #00e5ff55; }
    #pumpWrap .card{ background:var(--card-claro, #171a21); border-radius:16px; padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.35); }
    body.dark-mode #pumpWrap .card{ background:var(--card-oscuro, #171a21); }
    #pumpWrap .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    #pumpWrap .btn{ border:none; border-radius:12px; padding:12px 16px; font-weight:800; cursor:pointer; }
    #pumpWrap #btnRelay.on{ background:#00e676; color:#003a1f; }
    #pumpWrap #btnRelay.off{ background:#f00909; color:#fff6ea; }
    #pumpWrap #btnRelay:disabled{ opacity:.75; cursor:not-allowed; }
    #pumpWrap .msg{ font-size:13px; margin-top:8px; }
    #pumpWrap .msg.ok{ color:#69f0ae; } 
    #pumpWrap .msg.err{ color:#ff5252; } 
    #pumpWrap .muted{ color:#a9b3c1; }
    #pumpWrap .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:14px; margin-top:14px; }
    @media (max-width:700px){ #pumpWrap .grid{ grid-template-columns: 1fr; } }
    #pumpWrap code{ background:#0c0f13; padding:2px 6px; border-radius:6px; }
    #pumpWrap .note{ font-size:13px; color:#a9b3c1; margin-top:8px; }
  
@keyframes blinkBorder {
  0%   { box-shadow: 0 0 10px 2px red; }
  50%  { box-shadow: 0 0 0 0 red; }
  100% { box-shadow: 0 0 10px 2px red; }
}
.card.alerta, .card.critical { border: 2px solid red !important; animation: blinkBorder 1s infinite; }
</style>

</head>
<body>
  <!-- SPLASH -->
  <div id="splash">
    <div class="splash-content">
      <h1>BLADEN</h1>
      <p>20</p>
      <button onclick="ocultarSplash()">Entrar</button>
    </div>
  </div>

  <!-- DASHBOARD -->
  <header>
    <h1>üì° Dashboard LoRa ‚Äì Protegido</h1>
    <button id="toggleTheme">üåì Tema</button>
  </header>

  <div class="config">
    <div id="loginForm">
      üë§ Usuario: <input type="text" id="userInput" />
      üîë Contrase√±a: <input type="password" id="passInput" />
      <button onclick="verificarLogin()">Iniciar sesi√≥n</button>
    </div>

    <div id="loginStatus">--</div>

    <div id="panelConfig" style="display:none;">
      <div class="toolbar">
        <label>
          <input type="checkbox" id="bgEnabled" onchange="toggleBackground(this.checked)">
          üîÑ Seguir en segundo plano
        </label>
        <button id="wakeBtn" onclick="toggleWakeLock()">üõ°Ô∏è Mantener pantalla activa</button>
      </div>

      <label style="display:block;margin-top:.6rem;">
        <input type="checkbox" id="whatsEnabled" onchange="guardarPreferenciaWhatsApp()" /> Activar WhatsApp
      </label>

      <div style="margin: .5rem;">‚è±Ô∏è Intervalo entre alertas (min):
        <input id="alertInterval" type="number" min="1" value="1" style="width:60px;" onchange="guardarIntervalo()">
      </div>

      <div class="umbral-row">
        <label>üå°Ô∏è Temp > <input id="thTemp" type="number" step="0.1"> ¬∞C</label>
        <label>üíß Hum > <input id="thHum" type="number" step="0.1"> %</label>
        <label>üöø Flujo < <input id="thFlow" type="number" step="0.1"> L/min</label>
        <label>üîã Volt < <input id="thVolt" type="number" step="0.1"> V</label>
        <button onclick="guardarUmbrales()">Guardar</button>
      </div>

            <button id="testBtn" onclick="probarWhatsApp()">üì≤ Probar WhatsApp</button>
      <div id="lastWhatsApp">√öltimo WhatsApp: --</div>
      <!-- üîå PUMP ‚Äì Control ON/OFF (field8) -->
      
      <section id="pumpWrap">
  <div class="card">
    <div class="row" style="flex-direction:column; align-items:center; gap:8px;">
      <button id="btnRelay" class="btn off" aria-pressed="false" type="button">üîå GUN: --</button>
      <span id="relayLastTime" class="muted" style="display:block; text-align:center;">√öltimo cambio: --</span>
    </div>
    <div id="relayMsg" class="msg" style="text-align:center;"></div>
  </div>
</section>

      <!-- üîå FIN CONTROL GUN -->

    <button id="logoutBtn" onclick="logout()" style="margin-top:12px;">üö™ Cerrar sesi√≥n</button>
    </div>
  </div>
  <div id="lastUpdate">√öltima actualizaci√≥n: --</div>
  <div class="cards" id="cardContainer"></div>
  <canvas id="chartCanvas" height="120"></canvas>

  <!-- MAPA -->
  <section class="map-card">
    <h2 style="text-align:center;margin:8px 0;">üó∫Ô∏è Ubicaci√≥n (GPS)</h2>
    <div id="map"></div>
    <div id="mapStatus">Sin coordenadas a√∫n‚Ä¶</div>
  </section>

  <div id="notif" class="notif"></div>

<script>
  /* ====== SPLASH ====== */
  function ocultarSplash() {
    const el = document.getElementById('splash');
    if (el) el.style.display = 'none';
  }
  // Sin auto-ocultar: el splash solo desaparece con el bot√≥n.

  /* ====== CONSTANTES ====== */
  const USER = "bladen";
  const PASS = "28433";
  const CHANNEL_ID = 3033478;
  const READ_API_KEY = "217V6P5DIT9GRVLA";
  const WRITE_API_KEY = "NAK04ON555J4UHDS";
  
// === Canal B (Control Relay) ===
const CTRL_CHANNEL_ID    = 3073117;
const CTRL_READ_API_KEY  = "DL1I0ZDKIO9NO862";
const CTRL_WRITE_API_KEY = "Q0DTGZ8U7Q7ZFJG6";
const notif = document.getElementById("notif");

  let ledTimer = 0;
  let timerInterval;
  let chart;

  const FIELDS = [
    { field: "field1", label: "üå°Ô∏è Temp (¬∞C)", color: "#ff6384" },
    { field: "field2", label: "üíß Humedad (%)", color: "#36a2eb" },
    { field: "field3", label: "üöø Flujo (L/min)", color: "#4bc0c0" },
    { field: "field4", label: "üîã Voltaje (V)", color: "#9966ff" },
    { field: "field5", label: "üí® Viento (km/h)", color: "#fcb045" }
  ];

  let umbrales = { temp: 30.0, hum: 70.0, flow: 0.0, volt: 3.0 };
  let intervaloMinutos = 1;
  const ultimosAlertas = {};

  /* ====== MAPA (Leaflet) ====== */
  let map, marker;
  function ensureMap() {
    if (!map) {
      map = L.map('map', { zoomControl: true }).setView([0, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap'
      }).addTo(map);
    }
  }
  function updateMap(lat, lon) {
    ensureMap();
    const status = document.getElementById('mapStatus');
    if (Number.isFinite(lat) && Number.isFinite(lon)) {
      if (!marker) marker = L.marker([lat, lon]).addTo(map);
      else marker.setLatLng([lat, lon]);
      map.setView([lat, lon], 14);
      status.textContent = `Lat: ${lat.toFixed(5)}, Lon: ${lon.toFixed(5)}`;
    } else {
      status.textContent = 'Sin coordenadas en el √∫ltimo feed.';
    }
  }

  /* ====== UI helpers ====== */
  function mostrarNotif(msg) {
    // Toast interno
    notif.textContent = msg;
    notif.classList.add("show");
    setTimeout(() => notif.classList.remove("show"), 3000);

    // Notificaci√≥n nativa si la p√°gina est√° oculta y hay permiso
    if (document.hidden && window.Notification && Notification.permission === 'granted') {
      try { new Notification('Dashboard LoRa', { body: msg }); } catch(e){}
    }
  }

  async function pedirPermisoNotificaciones() {
    if (!("Notification" in window)) return false;
    if (Notification.permission === "granted") return true;
    if (Notification.permission === "denied") return false;
    const res = await Notification.requestPermission();
    return res === "granted";
  }

  /* ====== Login ====== */
  function verificarLogin() {
    const user = document.getElementById("userInput").value;
    const pass = document.getElementById("passInput").value;
    if (user === USER && pass === PASS) {
      localStorage.setItem("authOK", "1");
      habilitarConfiguracion(true);
      mostrarNotif("‚úÖ Sesi√≥n iniciada");
    } else {
      alert("‚ùå Credenciales incorrectas");
    }
  }
  function logout() {
    localStorage.removeItem("authOK");
    habilitarConfiguracion(false);
    detenerBackground();
    mostrarNotif("üö™ Sesi√≥n cerrada");
  }
  function habilitarConfiguracion(activo) {
    document.getElementById("panelConfig").style.display = activo ? "block" : "none";
    document.getElementById("loginForm").style.display = activo ? "none" : "block";
    document.getElementById("logoutBtn").style.display = activo ? "inline-block" : "none";
    document.getElementById("loginStatus").innerText = activo ? "‚úÖ Sesi√≥n iniciada" : "--";
  }

  /* ====== Preferencias ====== */
  function guardarUmbrales() {
    umbrales.temp = parseFloat(document.getElementById("thTemp").value);
    umbrales.hum  = parseFloat(document.getElementById("thHum").value);
    umbrales.flow = parseFloat(document.getElementById("thFlow").value);
    umbrales.volt = parseFloat(document.getElementById("thVolt").value);
    localStorage.setItem("umbrales", JSON.stringify(umbrales));
    mostrarNotif("üíæ Umbrales guardados");
    loadData();
  }
  function cargarUmbrales() {
    const u = JSON.parse(localStorage.getItem("umbrales"));
    if (u) umbrales = u;
    document.getElementById("thTemp").value = umbrales.temp;
    document.getElementById("thHum").value = umbrales.hum;
    document.getElementById("thFlow").value = umbrales.flow;
    document.getElementById("thVolt").value = umbrales.volt;
  }
  function guardarPreferenciaWhatsApp() {
    const estado = document.getElementById("whatsEnabled").checked;
    localStorage.setItem("whatsEnabled", estado ? "1" : "0");
    mostrarNotif(estado ? "üì≤ WhatsApp activado" : "üîï WhatsApp desactivado");
  }
  function cargarPreferenciaWhatsApp() {
    const enabled = localStorage.getItem("whatsEnabled") === "1";
    document.getElementById("whatsEnabled").checked = enabled;
    return enabled;
  }
  function guardarIntervalo() {
    intervaloMinutos = parseInt(document.getElementById("alertInterval").value);
    localStorage.setItem("alertInterval", intervaloMinutos);
    mostrarNotif("üíæ Intervalo guardado");
  }
  function cargarIntervalo() {
    const val = parseInt(localStorage.getItem("alertInterval"));
    intervaloMinutos = isNaN(val) ? 1 : val;
    document.getElementById("alertInterval").value = intervaloMinutos;
  }

  /* ====== Notificaciones WhatsApp ====== */
  function enviarWhatsApp(msg) {
    const url = `https://api.callmebot.com/whatsapp.php?phone=+5212311560234&text=${encodeURIComponent(msg)}&apikey=4036182`;
    fetch(url)
      .then(() => { actualizarUltimoWhatsApp(); mostrarNotif("‚úÖ WhatsApp enviado"); })
      .catch(() => { actualizarUltimoWhatsApp(); mostrarNotif("‚ö†Ô∏è WhatsApp con error"); });
  }
  function probarWhatsApp() { enviarWhatsApp("üì° Prueba de notificaci√≥n desde el Dashboard LoRa"); }
  function actualizarUltimoWhatsApp() {
    const ahora = new Date().toLocaleString("es-MX");
    document.getElementById("lastWhatsApp").innerText = "√öltimo WhatsApp: " + ahora;
    localStorage.setItem("ultimoWhatsApp", ahora);
  }
  function cargarUltimoWhatsApp() {
    const t = localStorage.getItem("ultimoWhatsApp") || "--";
    document.getElementById("lastWhatsApp").innerText = "√öltimo WhatsApp: " + t;
  }

  /* ====== Datos + Gr√°fica + Mapa ====== */
  function pintarUIconFeeds(data) {
    const feeds = data.feeds || [];
    const last = feeds[feeds.length - 1];

    if (last) {
      document.getElementById("lastUpdate").innerText = "√öltima actualizaci√≥n: " + new Date(last.created_at).toLocaleString("es-MX");
    }

    // Tarjetas
    const cardContainer = document.getElementById("cardContainer");
    cardContainer.innerHTML = "";
    if (last) {
      FIELDS.forEach((f, i) => {
        const valNum = parseFloat(last[f.field]);
        const val = isNaN(valNum) ? "--" : valNum.toFixed(1);
        let isCritical = false;
        if (i === 0 && valNum > umbrales.temp) isCritical = true;
        if (i === 1 && valNum > umbrales.hum)  isCritical = true;
        if (i === 2 && valNum < umbrales.flow) isCritical = true;
        if (i === 3 && valNum < umbrales.volt) isCritical = true;

        const ahora = Date.now();
        const clave = f.field;
        if (isCritical && (!ultimosAlertas[clave] || ahora - ultimosAlertas[clave] > intervaloMinutos * 60000)) {
          ultimosAlertas[clave] = ahora;
          if (document.getElementById("whatsEnabled").checked) {
            enviarWhatsApp(`‚ö†Ô∏è Alerta: ${f.label} fuera de rango: ${val}`);
          }
          // Notificaci√≥n nativa expl√≠cita de alerta cuando est√° oculto
          if (document.hidden) {
            mostrarNotif(`‚ö†Ô∏è ${f.label} fuera de rango: ${val}`);
          }
        }

        const card = document.createElement("div");
        card.className = "card" + (isCritical ? " critical" : "");
        card.innerHTML = `<h2>${f.label}</h2><p style="font-size:1.4em;">${val}</p>`;
        cardContainer.appendChild(card);
      });
    }

    // Gr√°fica
    if (chart) chart.destroy();
    const labelDates = feeds.map(x => new Date(x.created_at));
    const labels = labelDates.map(d => d.toLocaleTimeString("es-MX"));
    const datasets = FIELDS.map(f => ({
      label: f.label,
      data: feeds.map(x => parseFloat(x[f.field])),
      borderColor: f.color, fill: false, tension: 0.1
    }));
    chart = new Chart(document.getElementById("chartCanvas"), {
      type: "line",
      data: { labels, datasets },
      options: {
        responsive: true,
        plugins: { 
          legend: { position: "bottom" },
          tooltip: {
            callbacks: {
              title: (items) => {
                try {
                  const i = items && items.length ? items[0].dataIndex : 0;
                  const d = labelDates[i];
                  if (!d) return "";
                  const fecha = d.toLocaleDateString("es-MX");
                  const hora  = d.toLocaleTimeString("es-MX");
                  return `${hora}
${fecha}`; // dos l√≠neas: hora arriba, fecha abajo
                } catch(e){ return ""; }
              }
            }
          }
        },
        scales: {
          x: { ticks: { color: document.body.classList.contains("dark-mode") ? "#eee" : "#333" } },
          y: { ticks: { color: document.body.classList.contains("dark-mode") ? "#eee" : "#333" } }
        }
      }
    });

    // Geo desde field6/field7
    const lat = last ? parseFloat(last.field6) : NaN;
    const lon = last ? parseFloat(last.field7) : NaN;
    updateMap(lat, lon);
  }

  async function loadData() {
    try {
      const res = await fetch(`https://api.thingspeak.com/channels/${CHANNEL_ID}/feeds.json?api_key=${READ_API_KEY}&results=60`);
      const data = await res.json();
      pintarUIconFeeds(data);
    } catch (e) {
      console.error("Error cargando datos", e);
    }
  }

  /* ====== Tema ====== */
  function toggleTheme() {
    document.body.classList.toggle("dark-mode");
    localStorage.setItem("modoOscuro", document.body.classList.contains("dark-mode") ? "1" : "0");
    loadData(); // recargar gr√°fico con colores de ejes
  }
  function cargarTema() {
    if (localStorage.getItem("modoOscuro") === "1") {
      document.body.classList.add("dark-mode");
    }
  }

  /* ====== BACKGROUND: Worker + Notificaciones ====== */
  let bgWorker = null;
  let wakeLock = null;

  async function toggleBackground(enabled) {
    localStorage.setItem("bgEnabled", enabled ? "1" : "0");
    if (enabled) {
      const granted = await pedirPermisoNotificaciones();
      if (!granted) mostrarNotif("‚ÑπÔ∏è Notificaciones del sistema no concedidas");
      iniciarBackground();
    } else {
      detenerBackground();
    }
  }

  function iniciarBackground() {
    if (bgWorker) return;
    // C√≥digo del Worker como Blob para no requerir archivo externo
    const code = `
      const CHANNEL_ID = ${CHANNEL_ID};
      const READ_API_KEY = "${READ_API_KEY}";
      let intervalMs = 30000;

      async function loop() {
        try {
          const res = await fetch('https://api.thingspeak.com/channels/' + CHANNEL_ID + '/feeds.json?api_key=' + READ_API_KEY + '&results=60', {cache:'no-store'});
          const data = await res.json();
          const feeds = data.feeds || [];
          const last = feeds[feeds.length - 1] || null;

          postMessage({type:'data', data, lastAt: last ? last.created_at : null});
        } catch (e) {
          postMessage({type:'error', error: String(e)});
        } finally {
          setTimeout(loop, intervalMs);
        }
      }
      onmessage = (ev) => {
        if (ev.data && ev.data.type === 'setInterval' && ev.data.ms) {
          intervalMs = ev.data.ms;
        } else if (ev.data === 'stop') {
          // No hay forma est√°ndar de cerrar desde dentro sin self.close(); lo hacemos:
          self.close();
        }
      };
      loop();
    `;
    const blob = new Blob([code], { type: "application/javascript" });
    const url = URL.createObjectURL(blob);
    bgWorker = new Worker(url);

    // Ajustar intervalo si el usuario configur√≥ algo (aqu√≠ fijo a 30s como en la UI)
    bgWorker.postMessage({type:'setInterval', ms: 30000});

    bgWorker.onmessage = (ev) => {
      const { type, data, led, lastAt } = ev.data || {};
      if (type === 'data') {
        // Guarda en localStorage para que no se pierda si est√° oculta
        try { localStorage.setItem('bg_lastData', JSON.stringify(data)); } catch(e){}
        if (!document.hidden) {
          // Si la pesta√±a est√° visible, actualizamos la UI
          pintarUIconFeeds(data);
          } else {
          // Si est√° oculta, mandamos un ping sutil (opcional)
          if (window.Notification && Notification.permission === 'granted' && lastAt) {
            new Notification('Dashboard LoRa', { body: `Datos actualizados: ${new Date(lastAt).toLocaleTimeString()}` });
          }
        }
      } else if (type === 'error') {
        // Guardamos el error por si hace falta depurar
        console.warn('BG error:', ev.data.error);
      }
    };

    document.addEventListener('visibilitychange', () => {
      // Al volver visible, si hay datos guardados del worker, pinta sin esperar
      if (!document.hidden) {
        const raw = localStorage.getItem('bg_lastData');
        if (raw) {
          try { pintarUIconFeeds(JSON.parse(raw)); } catch(e){}
        }
      }
    });
    mostrarNotif("‚ñ∂Ô∏è Segundo plano activado");
  }

  function detenerBackground() {
    if (bgWorker) {
      try { bgWorker.postMessage('stop'); } catch(e){}
      try { bgWorker.terminate(); } catch(e){}
      bgWorker = null;
      mostrarNotif("‚èπÔ∏è Segundo plano desactivado");
    }
  }

  async function toggleWakeLock() {
    // Solicita/Libera Wake Lock de pantalla
    try {
      if (!wakeLock) {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          mostrarNotif("üõ°Ô∏è Wake Lock activado");
          wakeLock.addEventListener('release', () => { wakeLock = null; mostrarNotif("üîì Wake Lock liberado"); });
        } else {
          mostrarNotif("‚ö†Ô∏è Wake Lock no soportado en este navegador");
        }
      } else {
        await wakeLock.release(); // disparar√° el listener de release
      }
    } catch (e) {
      mostrarNotif("‚ö†Ô∏è No fue posible cambiar Wake Lock");
    }
  }

  // Guarda/restaura el estado del toggle de segundo plano
  function cargarBackgroundPref() {
    const enabled = localStorage.getItem('bgEnabled') === '1';
    const chk = document.getElementById('bgEnabled');
    if (chk) chk.checked = enabled;
    if (enabled) iniciarBackground();
  }

  /* ====== Inicializaci√≥n ====== */
  cargarTema();
  cargarUmbrales();
  cargarIntervalo();
  cargarPreferenciaWhatsApp();
  cargarUltimoWhatsApp();
  if (localStorage.getItem("authOK") === "1") habilitarConfiguracion(true);
  document.getElementById("toggleTheme").addEventListener("click", toggleTheme);loadData();
  setInterval(loadData, 30000);
  cargarBackgroundPref();
</script>

<!-- üîå Script del PUMP -->
<script>
/* ======== CONFIG ======== */
const RELAY_FIELD  = 1;

/* ======== PERSISTENCIA (√∫ltimo estado confirmado) ======== */
const LS_KEY = "relay_last_state_v1";
function saveLastState(state, tsISO){
  try{ localStorage.setItem(LS_KEY, JSON.stringify({ state, ts: tsISO || new Date().toISOString() })); }catch(e){}
}
function loadLastState(){
  try{ return JSON.parse(localStorage.getItem(LS_KEY)) || null; }catch(e){ return null; }
}

/* ======== UI helpers ======== */
const relayBtn  = ()=>document.getElementById('btnRelay');
const relayMsg  = ()=>document.getElementById('relayMsg');
const relayLast = ()=>document.getElementById('relayLastTime');

function setRelayUI(state){
  const btn = relayBtn(); if(!btn) return;
  const on = state===1;
  btn.classList.toggle('on', on);
  btn.classList.toggle('off', !on);
  btn.textContent = on ? "üîå GUN: ON" : "üîå GUN: OFF";
  btn.setAttribute('aria-pressed', on ? "true":"false");
}
function setRelayStatus(text, ok=true){
  const el = relayMsg(); if(!el) return;
  el.textContent = text || "";
  el.className = "msg " + (ok ? "ok":"err");
}
function setRelayLast(tsISO){
  try{
    const el = relayLast(); if(!el) return;
    const d = tsISO ? new Date(tsISO) : new Date();
    el.textContent = "√öltimo cambio: " + d.toLocaleString('es-MX',{hour12:true});
  }catch(e){}
}

/* ======== Estado y timers ======== */
let relayState = null; // 0=OFF, 1=ON
let relayCooldownUntil = 0;
const TS_MIN_INTERVAL_MS = 16000;
const MAX_RETRIES = 3;
let relayCountdownTimer = null;

/* ======== ThingSpeak helpers ======== */
async function readRelayState(){
  try{
    const url = `https://api.thingspeak.com/channels/${CTRL_CHANNEL_ID}/fields/${RELAY_FIELD}/last.json?api_key=${CTRL_READ_API_KEY}&_=${Date.now()}`;
    const r = await fetch(url,{cache:'no-store'});
    const j = await r.json();
    const raw = j[`field${RELAY_FIELD}`];
    const v = Number(raw);
    if(!Number.isNaN(v)){
      const newState = v>0?1:0;
      const changed = (relayState===null) || (newState!==relayState);
      relayState = newState; setRelayUI(relayState);
      if(changed){
        const when = j.created_at || null;
        setRelayLast(when);
        saveLastState(relayState, when);
      }
    }
  }catch(e){ /* silencio */ }
}

async function writeRelayState(v){
  try{
    const resp = await fetch("https://api.thingspeak.com/update.json", {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8" },
      body: new URLSearchParams({ api_key: CTRL_WRITE_API_KEY, [`field${RELAY_FIELD}`]: String(v) })
    });
    const j = await resp.json().catch(()=>null);
    const entryId = (j && typeof j==="object") ? j.entry_id : NaN;
    const ok = !Number.isNaN(entryId) && entryId>0;
    if(ok){ setRelayStatus(v? "GUN encendido":"GUN apagado", true); setRelayLast(); saveLastState(v?1:0); }
    else { setRelayStatus("No se pudo escribir (posible l√≠mite de 15s o clave inv√°lida).", false); }
    return ok;
  }catch(e){
    setRelayStatus("Error de red al escribir en ThingSpeak.", false);
    return false;
  }
}

async function getChannelLastInfo(){
  try{
    const url = `https://api.thingspeak.com/channels/${CTRL_CHANNEL_ID}/feeds/last.json?_=${Date.now()}`;
    const r = await fetch(url,{cache:'no-store'});
    const j = await r.json();
    const ts = j && j.created_at ? new Date(j.created_at).getTime() : null;
    if(!ts) return null;
    const diff = Date.now() - ts;
    const msUntilOpen = Math.max(0, TS_MIN_INTERVAL_MS - diff);
    return { lastAt: ts, msUntilOpen };
  }catch(e){ return null; }
}

/* ======== Cuenta regresiva en el bot√≥n ======== */
function startRelayCountdown(ms){
  const btn = relayBtn(); if(!btn) return;
  btn.disabled = true;
  const base = (relayState===1) ? "üîå GUN: ON" : "üîå GUN: OFF";
  const end = Date.now() + ms;
  function tick(){
    const left = Math.max(0, end - Date.now());
    const s = Math.ceil(left/1000);
    btn.textContent = `${base} (‚è≥ ${s}s)`;
    if(left<=0){ stopRelayCountdown(); }
  }
  stopRelayCountdown();
  relayCountdownTimer = setInterval(tick, 250);
  tick();
}
function stopRelayCountdown(){
  const btn = relayBtn();
  if(btn){
    btn.disabled = false;
    setRelayUI(relayState===1?1:0);
  }
  if(relayCountdownTimer){ clearInterval(relayCountdownTimer); relayCountdownTimer=null; }
}

/* ======== Ventana m√≠nima ThingSpeak ======== */
async function ensureChannelOpenWithCountdown(){
  const info = await getChannelLastInfo();
  if(info && info.msUntilOpen>0){
    startRelayCountdown(info.msUntilOpen);
    await new Promise(res=>setTimeout(res, info.msUntilOpen));
    stopRelayCountdown();
  }
}

/* ======== Reintentos (3) ======== */
async function doToggleWithRetries(next, tries){
  await ensureChannelOpenWithCountdown();
  setRelayStatus("Enviando‚Ä¶");
  const ok = await writeRelayState(next);
  if(ok) return true;
  if(tries<=1){
    setRelayStatus("No se pudo escribir despu√©s de reintentos.", false);
    return false;
  }
  // Backoff peque√±o antes del siguiente intento
  startRelayCountdown(3000);
  await new Promise(res=>setTimeout(res, 3000));
  stopRelayCountdown();
  return await doToggleWithRetries(next, tries-1);
}

/* ======== Handler del bot√≥n ======== */
async function toggleRelay(){
  const now = Date.now();
  if(now < relayCooldownUntil){
    const waitMs = relayCooldownUntil - now;
    setRelayStatus("Espera un momento antes de otro cambio.", false);
    startRelayCountdown(waitMs);
    setTimeout(()=>{
      if(Date.now() >= relayCooldownUntil){
        stopRelayCountdown();
        setRelayStatus("", true);
      }
    }, waitMs + 120);
    return;
  }
  const next = (relayState===1) ? 0 : 1;
  const ok = await doToggleWithRetries(next, MAX_RETRIES);
  if(ok){
    relayState = next;
    setRelayUI(relayState);
    const cd = Math.max(TS_MIN_INTERVAL_MS, 5000);
    relayCooldownUntil = now + cd;
    setRelayStatus("Cambio aplicado. Espera para el siguiente‚Ä¶", true);
    startRelayCountdown(cd);
    setTimeout(()=>{ stopRelayCountdown(); setRelayStatus("", true); }, cd + 120);

    /* üëâ Notificaci√≥n flotante al aplicar */
    mostrarNotif(next ? "‚úÖ GUN encendido" : "‚èπÔ∏è GUN apagado");
  }
}

/* ======== Bootstrap ======== */
(function init(){
  // 1) Pintar √∫ltimo estado guardado al entrar
  const saved = loadLastState();
  if(saved && (saved.state===0 || saved.state===1)){
    relayState = saved.state;
    setRelayUI(relayState);
    setRelayLast(saved.ts || null);
  } else {
    setRelayUI(0);
  }
  // 2) Enlazar bot√≥n
  const btn = relayBtn();
  if(btn){ btn.addEventListener("click", toggleRelay); }
  // 3) Lectura peri√≥dica desde ThingSpeak
  readRelayState();
  setInterval(readRelayState, 30000);
})();
</script>


<!-- ===== Patch: PUMP worker por intenci√≥n (modo r√°faga) ===== -->
<script>
(function(){
  'use strict';
  // Asumimos que existen en el dashboard:
  // CHANNEL_ID, READ_API_KEY, WRITE_API_KEY, RELAY_FIELD
  // Funciones utilitarias: relayBtn(), setBtnUI(state,pending), setRelayStatus(msg,ok),
  //  readRelayState(), writeRelayState(target), startRelayCountdown(ms),
  //  stopRelayCountdown(), fmtDate(d), persistLastChange(state) [opcional]
  // Estados globales: relayState, relayCooldownUntil, TS_MIN_INTERVAL_MS
  window.TS_MIN_INTERVAL_MS = window.TS_MIN_INTERVAL_MS || 15000;

  let desiredState = null;   // 0/1 √∫ltima intenci√≥n
  let applying     = false;  // loop activo
  let intentVer    = 0;      // versi√≥n para cancelar intentos viejos
  let debounceTmr  = null;   // compresor de clics

  // Helpers m√≠nimos si no existieran en el archivo original
  window.relayBtn = window.relayBtn || function(){ return document.getElementById('relayBtn'); };
  window.setBtnUI = window.setBtnUI || function(state, pending){
    const btn = relayBtn(); if(!btn) return;
    btn.classList.toggle('on', state===1);
    btn.classList.toggle('off', state!==1);
    const label = state===1 ? 'GUN: ON' : 'GUN: OFF';
    btn.innerHTML = `üîå <b>${label}${pending?' (pend.)':''}</b>`;
  };
  window.setRelayStatus = window.setRelayStatus || function(msg, ok){
    const el = document.getElementById('status') || document.getElementById('relayStatus');
    if(!el) return;
    el.style.color = ok ? '#a1e3b8' : '#ffbdbd';
    el.textContent = msg||'';
  };
  window.startRelayCountdown = window.startRelayCountdown || function(ms){
    const badge = document.getElementById('cooldownBadge'); if(!badge) return;
    const cd = document.getElementById('cdSecs') || badge.querySelector('[data-cd]') || badge;
    badge.style.display = 'inline-flex';
    function tick(){
      const left = Math.max(0, Math.ceil(((window.relayCooldownUntil||0) - Date.now())/1000));
      cd.textContent = left;
      if(left<=0){ badge.style.display='none'; clearInterval(tmr); }
    }
    tick();
    const tmr = setInterval(tick, 250);
  };
  window.stopRelayCountdown = window.stopRelayCountdown || function(){
    const badge = document.getElementById('cooldownBadge'); if(badge) badge.style.display='none';
  };

  async function getLastFeedTime(){
    try{
      const url = `https://api.thingspeak.com/channels/${CHANNEL_ID}/feeds/last.json?api_key=${CTRL_READ_API_KEY}`;
      const res = await fetch(url, {cache:'no-store'});
      const data = await res.json();
      return new Date(data.created_at).getTime();
    }catch(_){ return 0; }
  }
  async function ensureChannelOpenWithCountdown(){
    const last = await getLastFeedTime();
    const now  = Date.now();
    const waitMs = Math.max(0, (last + window.TS_MIN_INTERVAL_MS) - now);
    if(waitMs > 0){
      window.relayCooldownUntil = now + waitMs;
      startRelayCountdown(waitMs);
      let left = waitMs;
      while(left > 0){
        await new Promise(r=>setTimeout(r, Math.min(250, left)));
        const n = Date.now();
        left = (last + window.TS_MIN_INTERVAL_MS) - n;
      }
      stopRelayCountdown();
    }
  }
  async function verifyApplied(target){
    try{ await new Promise(r => setTimeout(r, 900)); }catch(e){}
    if(typeof readRelayState === 'function'){ await readRelayState(); }
    return (window.relayState === target);
  }
  function scheduleApply(){
    if(debounceTmr) clearTimeout(debounceTmr);
    debounceTmr = setTimeout(()=>{
      debounceTmr = null;
      if(!applying) applyDesiredLoop();
    }, 350); // colapsa clics r√°pidos
  }
  
async function applyDesiredLoop(){
  applying = true;
  try{
    while(desiredState !== null){
      const myVer = intentVer;
      const target = desiredState;
      await ensureChannelOpenWithCountdown();
      if(myVer !== intentVer) continue; // usuario cambi√≥ de idea

      setRelayStatus("Enviando‚Ä¶");
      const ok = await writeRelayState(target);
      if(!ok){
        // Un solo reintento suave si fall√≥ la escritura HTTP
        await new Promise(r=>setTimeout(r, 1200));
        const ok2 = await writeRelayState(target);
        if(!ok2){
          setRelayStatus("No se confirm√≥ el cambio; espera y vuelve a intentar.", false);
          // salimos del bucle para no insistir; usuario puede volver a pulsar
          desiredState = null;
          break;
        }
      }

      // Escritura OK: damos por aplicado SIN requerir confirmaci√≥n inmediata (sin ACK).
      relayState = target;
      setBtnUI(target, false);
      setRelayStatus("Cambio aplicado. Espera para el siguiente‚Ä¶", true);

      /* üëâ Notificaci√≥n flotante al aplicar (patch por intenci√≥n) */
      try{ if (typeof mostrarNotif === 'function') { mostrarNotif(target ? "‚úÖ GUN encendido" : "‚èπÔ∏è GUN apagado"); } }catch(_){}

      const cd = Math.max(window.TS_MIN_INTERVAL_MS || 15000, 4000);
      window.relayCooldownUntil = Date.now() + cd;
      startRelayCountdown(cd);
      // Limpieza y fin de intenci√≥n
      desiredState = null;
      await new Promise(r=>setTimeout(r, cd + 50));
      stopRelayCountdown();
    }
  } finally {
    applying = false;
  }
}

  // Sobrescribe el handler del bot√≥n para programar intenci√≥n
  window.toggleRelay = function(){
    const base = (desiredState === 0 || desiredState === 1) ? desiredState : (window.relayState===1?1:0);
    const next = base === 1 ? 0 : 1;
    desiredState = next;
    intentVer++;
    setRelayStatus(`Programado: ${next ? "ON" : "OFF"}`, true);
    setBtnUI(next, true);
    scheduleApply();
  };

  // Conecta el click si es necesario
  try{
    const b = relayBtn && relayBtn();
    if(b){ b.removeEventListener('click', window.toggleRelay); b.addEventListener('click', window.toggleRelay); }
  }catch(_){}
})();
</script>
<!-- ===== Fin del patch ===== -->

</body>
</html>
